-- the following comment is generated by chatgpt
--
-- Overall, this code implements a UART receiver that receives serial data, 
-- detects start, data, parity, and stop bits, 
-- and provides the received data on m_axi_data_tdata. 
-- It also sets m_axi_data_tvalid to indicate the validity of the received data 
-- and err_parity to indicate any parity errors.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity spi_slave is
  generic (
    C_SERIAL_DATA_W : natural
  );
  port (
    clock             : in std_logic;
    reset             : in std_logic;
    
    CSN               : in std_logic;
    SCK               : in std_logic;
    MOSI              : in std_logic;
    MISO              : out std_logic;
    
    s_axi_data_tvalid : in std_logic;
    s_axi_data_tdata  : in std_logic_vector(C_SERIAL_DATA_W-1 downto 0);
    m_axi_data_tvalid : out std_logic;
    m_axi_data_tdata  : out std_logic_vector(C_SERIAL_DATA_W-1 downto 0)
  );
end spi_slave;

architecture str of spi_slave is

  -- Type definitions
  type t_STATE is (
    IDLE_ST,
    XFER_ST
  );

  constant C_SRL              : natural := 3;

  -- Signal definitions
  signal csn_sr                 : std_logic_vector(C_SRL-1 downto 0);
  signal sck_sr                 : std_logic_vector(C_SRL-1 downto 0);
  signal mosi_sr                : std_logic_vector(C_SRL-1 downto 0);
  
  signal spi_slave_state       : t_STATE;
  signal st_sym_cntr           : natural range C_SERIAL_DATA_W-1 downto 0;
  -- signal st_sym_cntr           : unsigned(UNSIGNED_NUM_BITS(C_SERIAL_DATA_W) downto 0);
  signal st_rcvd_data          : std_logic_vector(m_axi_data_tdata'range);
  signal st_rcvd_valid         : std_logic;

begin

  -- Process to create delayed versions of inputs
  process (clock, reset)
  begin
    if reset = '1' then
      -- Reset the delayed versions of inputs
      csn_sr  <= (others => '0');
      sck_sr  <= (others => '0');
      mosi_sr <= (others => '0');
    elsif rising_edge(clock) then
      -- Create delayed versions of inputs
      csn_sr  <= csn_sr(C_SRL-2 downto 0) & CSN;
      sck_sr  <= sck_sr(C_SRL-2 downto 0) & SCK;
      mosi_sr <= mosi_sr(C_SRL-2 downto 0) & MOSI;
    end if;
  end process;
  
  -- Main process for SPI functionality
  process (clock, reset)
  begin
    if reset = '1' then
      -- Reset condition: Set the initial state and other variables
      spi_slave_state   <= IDLE_ST;
    elsif rising_edge(clock) then
      -- On rising edge of clock
      st_rcvd_valid <= '0';
      case spi_slave_state is
        when IDLE_ST =>
          -- Idle state
          st_sym_cntr     <= C_SERIAL_DATA_W - 1;
          st_parity       <= '0';
          
          -- detect falling edge of CSN signal
          if csn_sr(C_SRL-1 downto C_SRL-2) = "10" then
            -- Check for start bit
            spi_slave_state <= XFER_ST;
          end if;
          
        when XFER_ST =>
          -- detect rising edge of CSN signal
          if csn_sr(C_SRL-1 downto C_SRL-2) = "01" then
            -- Move to the idle state
            spi_slave_state     <= IDLE_ST;
          else
            -- put data to MISO on the falling edge of SCK
            if sck_sr(C_SRL-1 downto C_SRL-2) = "10" then
              MOSI    <= s_axi_data_tdata(st_sym_cntr);
            end if;
            
            -- sample the data on MOSI on the rising edge of SCK
            if sck_sr(C_SRL-1 downto C_SRL-2) = "01" then
              st_rcvd_data(st_sym_cntr)   <= mosi_sr(C_SRL-1);
              if st_sym_cntr = 0 then
                st_rcvd_valid     <= '1';
                st_sym_cntr       <= C_SERIAL_DATA_W - 1;
              else
                st_sym_cntr       <= st_sym_cntr - 1;
              end if;
            end if;
          end if;
          
        when others =>
          -- Handle other states (should not occur in this code)
          null;
      end case;
    end if;
  end process;
  
  -- Process for output generation
  process (clock)
  begin
    if rising_edge(clock) then
      m_axi_data_tvalid   <= '0';
      if (spi_slave_state = XFER_ST and st_rcvd_valid = '1') then
        m_axi_data_tvalid   <= '1';
        m_axi_data_tdata    <= st_rcvd_data;
      end if;
    end if;
  end process;

end str;
